# Function

函数：封装一个特定功能，表示一个行为。可以重复执行



## 函数定义与调用

### 函数定义

```python
# 函数的定义
def 函数名([形参列表]):
    函数体  # 逻辑处理，返回结果
```

说明：

- **def**为关键字，全程define
- 函数名就是语句块的名称
- 函数名的命名规则与变量相同，但一般用动词
- 函数外部不可访问函数内部变量，在函数内部可以访问外部变量，通常让函数处理外部数据需要用传参列表给函数出入一些参数
- 函数形参列表可以为空
- 函数体部分不能为空，若为空可以用pass语句代替



### 函数调用

```python
# 函数的调用
函数名([实参列表])

# 获取函数地址
函数名
```

说明：

- 函数调用是一个表达式
- 若没有__return语句__，此函数执行完毕后返回对象为__None__；若要返回其他对象，需要用return语句
- 单独写函数名不加括号，是获取函数的地址



### return 语句

用于函数中，结束当前函数的执行，返回到调用该函数的地方，同时返回一个对象的引用关系

```python
return [表达式]
```

说明：

- **return** **语句后的表达式可以省略，省略后相当于** **return None**

- 如果函数没有return语句，着函数执行最后一条语句后返回None（相当于加了一条return None语句）
- 函数调用一定会返回一个对象的引用



## 参数传递

### 函数实参传递方式

- 位置传参
  - 位置传参：实参的对应关系与形参的对应关系是按位置来依次对应的
  - 序列传参：在函数调用过程中，用 ***** 将序列拆解后按位置传参的方式进行参数传递
- 关键字传参
  - 关键字传参：在传参时，按照形参的名称给形参赋值，形参和实参按名称进行匹配
  - 字典关键字传参：指实参为字典，将字典用两个星号 ***\*** 拆解后进行关键字传参的传递方式

```python
def myfun(a, b, c):
    pass

# 位置传参
myfun(1, 2, 3)
# 要求实参个数与形参个数相同

# 序列传参
s1 = 'abc'
s2 = [1, 2, 3]
myfun(*s1)  # 等同于myfun('a', 'b', 'c')
myfun(*s2)  # 等同于myfun(s2[0], s2[1], s2[2])
# 序列传参时，序列拆解的位置将与形参位置一一对应

# 关键字传参
myfun(b = 2, a = 1, c = 3) # 等同于myfun(1, 2, 3)
# 实参与形参按名称进行匹配，可以不按位置进行匹配
# 实参中关键字要在形参中存在

# 字典关键字传参
D = {'c':3, 'a':1, 'b':2}
myfun(**D) # 等同于myfun(d['a'], d['b'], d['c'])
# 字典的键名和形参名一致
# 字典的键必须为字符串
# 字典的键要在形参中存在
```



### 函数形参定义方式

- 位置形参
  - 位置形参：按位置顺序书写形参
  - 星号元组形参：用于不确定位置传参个数时，收集多合的位置传参，元组名通常用args
- 命名关键字形参
  - 命名关键字形参：强制实参使用关键字传递
  - 双星号字典形参：用于不确定关键字传参个数时,收集多余的关键字传参，字典形参通常定义为**kwargs

```python
# 位置形参
def myfunc(a, b, c):
    pass
```

```python
# 星号元组形参
def 函数名(*元组形参名):
    pass

def func(*args):
    print(args)
    print(len(args))

func(1, 2, 3, 4)  # args = (1, 2, 3, 4)
func(*'hello', 'world', 1, 2, 3)  # args = ('h', 'e', 'l', 'l', 'o', 'world', 1, 2, 3)
```

```python
# 命名关键字形参
def 函数名(*, 参数名):
    pass

def 函数名(*args, 参数名):
    pass


def fn(*, d, e):
    print(d, e)
    
fn(d=1, e=2)
fn(1, 2)  # error


def fm(*args, d, e):
    print(args)
    print(d, e)
    
fm(1, 2, d=1, e=2)
fm(*'ab', **{'e':2, 'd':1})


def f1(a, b, *, c, d):
    pass
f1(1, 2, c=3, d=4)

def f2(a, b, *args, c, d):
    pass
f2(1, 2, c=3, d=4)
```

```python
# 双星号字典形参
def 函数名(**kwargs):
    pass

def fn(**kwargs):
    print(kwargs)
fn(a=1, b=2, c=3)  # kwargs = {'a':1, 'c':3, 'b':2}
```



### 缺省参数

又称为默认参数，在函数定义时，给形参赋值，调用函数时可以不传入实参，则使用缺省值

作用：让调用更方便，无需传入无关实参

```python
def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ...):
    pass

def info(name, age=0, address=None):
    print(name, '今年', age, '岁, 住址是', address)
    
infor('A', 15)  # A今年15岁住址是:None
info('B', 20, 'Beijing') # B今年20岁住址是:Beijing
```

注意：**缺省参数必须自右至左依次存在，若有一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数**



### 函数综合传参

- 函数的传参方式，在形参能唯一匹配到实参的情况下，可以任意组合
- 函数的**位置传参要先于关键字传参**

- **实参给形参进行赋值传递，并不会复制新的对象**
- 缺省参数、位置形参、星号元组形参、命名关键字形参和双星号字典形参可以混合使用

函数参数从左自右的顺序为：__位置--星号元组--命名关键字--双星号字典__

```python
def fn(a,b,*args, c, **kwargs):
	pass
		
fn(1,2,3,4,d=6,c=5,e=7)
# a= 1, b=2, args=(3,4),c=5,kwargs={'d':6,'e':7}
		
fn(*'hello',d=6, **{'c':5, 'e':7})
# a='h', b='e',args=('l','l','o'),c=5,kwargs={'d':6,'e':7}
```



## 可变类型和不可变类型在传参时的区别

- 不可变类型：
  - 字符串
  - 元组
  - 固定集合
  - 整数、浮点数、复数

- 可变类型：
  - 列表
  - 字典
  - 集合

- 不可变类型的数据传参时，函数内部不会改变原数据的值。

- 可变类型的数据传参时，函数内部可能改变原数据的值



## Python作用域

作用域也叫名字空间，是访问变量时查找变量名的范围空间

Python中的四个作用域：**LEGB**

- **局部作用域**：**Local**

- **外部嵌套函数作用域**：**Enclosing**

- **函数定义域所在模块（文件）的作用于**：**Global** **（** **Mudule** **）**

- **Python** **内置模块的作用域**：**Builtin**

变量名查找规则：**L** **-->** **E** **-->** **G** **-->** **B**



局部变量：

> 定义在函数内部的变量，**局部变量只能在内部使用**，**局部变量只在函数被调用时才能被创建，在函数调用后被销毁。形参也是局部变量。**

全局变量：

> 定义在函数外部、模块内部的变量，所有函数都可以直接访问，但函数内部不能将其直接赋值。

```python
globals()
# 返回当前全局作用域内的变量的字典
locals()
# 返回当前局部作用域内的变量的字典

a = 1
b = 2
c = 3
def fun(c, d):
	e  = 300
	print(locals())
	print(globals())
			
fun(100, 200)
# {'e': 300, 'c': 100, 'd':200}
# {'a': 1, 'c': 3, 'b':2}
```



__global语句__

- 告诉解释器，global语句声明的一个或多个变量，这些变量的作用域为模块级别的作用域，也称作全局变量
- 全局声明将赋值变量映射到模块内部的作用域

```python
# 语法
def func():
	global 变量1, 变量2, ...
    ...

v = 1
def f():
	global v # 若没有此句，全局的v的值不会被改变，打印结果为1
	v = 2

f()
print(v) # 2
```

说明：

- 全局变量要在函数内部被赋值，则必须经过全局声明，否则被视为局部变量
- 全局变量在函数内部不经过声明就可以直接访问，（拿到引用关系，不能改变变量）
- 不能先声明局部变量，再用global声明为全局变量，不合规则
- global变量列表里的变量不能出现在此作用域内的形参列表里



__nonlocal语句__

告诉解释器，nonlocal声明的变量不是局部变量，也不是全局变量，而是外部嵌套函数内部的变量

```python
def outer_func():
    ...
    def inner_func():
        nonlocal 变量名1, 变量名2, ...
        ...
    ...
```

说明：

- nonlocal语句只能在被嵌套函数的内部使用
- 访问nonlocal变量将对外部嵌套函数的作用域的变量进行操作
- 当只有两层或两层以上的函数嵌套时，访问nonlocal变量只对最近一层变量进行操作
- nonlocal语句的变量列表里的变量名不能出现在此函数的参数列表中



## 函数嵌套

在一个函数里，用def语句来创建其他函数

```python
def f1():
    ...
    def f2():
        ...
    ...
```



## 函数的属性

| 函数属性   | 说明                         | 使用                                                         |
| ---------- | ---------------------------- | ------------------------------------------------------------ |
| `__doc__`  | 用于绑定函数的**文档字符串** | `函数名.__doc__`                                             |
| `__name__` | 用于**绑定函数的名称**       | 对于普通函数，`函数名.__name__` 得到的是`函数名`; 对于匿名函数，`函数名.__name__` 得到的是`<lambda>` |
|            |                              |                                                              |



### 函数的文档字符串

在函数内部，第一个没有赋值给任何变量的字符串称为文档字符串。通常让调用者查看，明白函数的功能

```python
def 函数名(形参列表)：
	'''函数文档字符串'''
	函数体

# 查看函数文档字符串
函数名.__doc__
    
# 可以利用交互模式下help查看，语法：
>>> help(函数名)

# 查看函数名
函数名.__name__
```

